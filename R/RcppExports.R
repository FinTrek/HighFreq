# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate the variance of a vector using \emph{Rcpp}.
#' 
#' @param vec_tor A numeric \emph{vector} of data.
#'
#' @return A single \emph{numeric} value.
#'
#' @details The function \code{vari_ance()} calculates the variance of a vector
#'   using \emph{Rcpp}. The function \code{vari_ance()} is slightly faster than
#'   the \emph{R} function \code{var()}.
#' 
#' @examples
#' \dontrun{
#' # calculate variance 
#' HighFreq::vari_ance(rnorm(1000))
#' }
#' @export
vari_ance <- function(vec_tor) {
    .Call('_HighFreq_vari_ance', PACKAGE = 'HighFreq', vec_tor)
}

#' Calculate the rolling sum over a vector using \emph{Rcpp}.
#' 
#' @param vec_tor A numeric \emph{vector} of data.
#' @param look_back The length of the look-back interval, equal to the number 
#'   of elements of data used for calculating the sum.
#'
#' @return A numeric \emph{vector} of the same length as the argument
#'   \code{vec_tor}.
#'
#' @details The function \code{roll_sum()} calculates a \emph{vector} of 
#'   rolling sums, over a \emph{vector} of data, using \emph{Rcpp}.  The
#'   function \code{roll_sum()} is over six times faster than
#'   \code{rutils::roll_sum()} which uses vectorized \emph{R}.
#'
#' @examples
#' \dontrun{
#' # calculate rolling sums over 11-period intervals
#' sum_rolling <- HighFreq::roll_sum(rnorm(1000), look_back=11)
#' }
#' @export
roll_sum <- function(vec_tor, look_back) {
    .Call('_HighFreq_roll_sum', PACKAGE = 'HighFreq', vec_tor, look_back)
}

#' Calculate the rolling weighted sum over a vector using \emph{RcppArmadillo}.
#' 
#' @param vec_tor A numeric \emph{vector} of data.
#' @param wei_ghts A numeric \emph{vector} of weights.
#'
#' @return A numeric \emph{vector} of the same length as the argument
#'   \code{vec_tor}.
#'
#' @details The function \code{roll_wsum()} calculates the rolling weighted sum
#'   of a vector over its past values (a convolution with the \emph{vector} of 
#'   weights), using \emph{RcppArmadillo}. It performs a similar calculation as
#'   the standard \emph{R} function \code{filter(x=vec_tor, filter=wei_ghts, 
#'   method="convolution", sides=1)}, but it's about six times faster, and it 
#'   doesn't produce any \emph{NA} values.
#'   
#' @examples
#' \dontrun{
#' # First example
#' # create vector from historical prices
#' vec_tor <- as.numeric(rutils::env_etf$VTI[, 6])
#' # create simple weights
#' wei_ghts <- c(1, rep(0, 10))
#' # calculate rolling weighted sum
#' weight_ed <- HighFreq::roll_wsum(vec_tor=vec_tor, wei_ghts=rev(wei_ghts))
#' # compare with original
#' all.equal(vec_tor, as.numeric(weight_ed))
#' # Second example
#' # create exponentially decaying weights
#' wei_ghts <- exp(-0.2*1:11)
#' wei_ghts <- wei_ghts/sum(wei_ghts)
#' # calculate rolling weighted sum
#' weight_ed <- HighFreq::roll_wsum(vec_tor=vec_tor, wei_ghts=rev(wei_ghts))
#' # calculate rolling weighted sum using filter()
#' filter_ed <- filter(x=vec_tor, filter=wei_ghts, method="convolution", sides=1)
#' # compare both methods
#' all.equal(as.numeric(filter_ed[-(1:11)]), as.numeric(weight_ed[-(1:11)]))
#' }
#' @export
roll_wsum <- function(vec_tor, wei_ghts) {
    .Call('_HighFreq_roll_wsum', PACKAGE = 'HighFreq', vec_tor, wei_ghts)
}

#' Calculate a time series of variance estimates over a rolling look-back
#' interval for an \emph{OHLC} time series of prices, using different range
#' estimators for variance.
#' 
#' Currently only works for vectors
#'
#' @param oh_lc An \emph{OHLC} time series of prices in \emph{xts} format.
#' @param calc_method \emph{character} string representing method for estimating
#'   variance.  The methods include:
#'   \itemize{
#'     \item "close" close to close,
#'     \item "garman_klass" Garman-Klass,
#'     \item "garman_klass_yz" Garman-Klass with account for close-to-open price jumps,
#'     \item "rogers_satchell" Rogers-Satchell,
#'     \item "yang_zhang" Yang-Zhang,
#'    }
#'    (default is \code{"yang_zhang"})
#' @param look_back The size of the look-back interval, equal to the number of rows
#'   of data used for calculating the variance.
#' @param sca_le \emph{Boolean} argument: should the returns be divided by the
#'   number of seconds in each period? (default is \code{TRUE})
#'
#' @return An \emph{xts} time series with a single column and the same number of
#'   rows as the argument \code{oh_lc}.
#'
#' @details The function \code{roll_var()} calculates a time series of rolling 
#'   variance estimates of percentage returns, from over a
#'   \emph{vector} of returns, using several different variance estimation
#'   methods based on the range of \emph{OHLC} prices.
#'
#'   If \code{sca_le} is \code{TRUE} (the default), then the variance is divided
#'   by the squared differences of the time index (which scales the variance to
#'   units of variance per second squared.) This is useful for example, when
#'   calculating intra-day variance from minutely bar data, because dividing
#'   returns by the number of seconds decreases the effect of overnight price
#'   jumps.
#'
#'   If \code{sca_le} is \code{TRUE} (the default), then the variance is
#'   expressed in the scale of the time index of the \emph{OHLC} time series.
#'   For example, if the time index is in seconds, then the variance is given in
#'   units of variance per second squared.  If the time index is in days, then
#'   the variance is equal to the variance per day squared.
#'
#'   The time index of the \code{oh_lc} time series is assumed to be in
#'   \emph{POSIXct} format, so that its internal value is equal to the number of
#'   seconds that have elapsed since the \emph{epoch}.
#'
#'   The methods \code{"close"}, \code{"garman_klass_yz"}, and
#'   \code{"yang_zhang"} do account for close-to-open price jumps, while the
#'   methods \code{"garman_klass"} and \code{"rogers_satchell"} do not account
#'   for close-to-open price jumps.
#'
#'   The default method is \code{"yang_zhang"}, which theoretically has the
#'   lowest standard error among unbiased estimators.
#'
#'   The function \code{roll_var()} performs the same calculations as the
#'   function \code{volatility()} from package
#'   \href{https://cran.r-project.org/web/packages/TTR/index.html}{TTR}, but
#'   it's a little faster because it uses function RcppRoll::roll_sd(), and it
#'   performs less data validation.
#'
#' @examples
#' \dontrun{
#' # create minutely OHLC time series of random prices
#' oh_lc <- HighFreq::random_ohlc()
#' # calculate variance estimates for oh_lc over a 21 period interval
#' var_rolling <- HighFreq::roll_var(oh_lc, look_back=21)
#' # calculate variance estimates for SPY
#' var_rolling <- HighFreq::roll_var(HighFreq::SPY, calc_method="yang_zhang")
#' # calculate SPY variance without accounting for overnight jumps
#' var_rolling <- HighFreq::roll_var(HighFreq::SPY, calc_method="rogers_satchell")
#' }
#' @export
roll_var <- function(vec_tor, look_back) {
    .Call('_HighFreq_roll_var', PACKAGE = 'HighFreq', vec_tor, look_back)
}

#' Calculate the eigen decomposition of the covariance matrix of returns using
#' \emph{RcppArmadillo}.
#' 
#' @param mat_rix A numeric \emph{matrix} of returns data.
#'
#' @return A list with two elements: a numeric \emph{vector} of eigenvalues 
#'   (named "values"), and a numeric \emph{matrix} of eigenvectors (named
#'   "vectors").
#'
#' @details The function \code{calc_eigen()} first calculates the covariance 
#'   matrix of the \code{mat_rix}, and then calculates its eigen decomposition.
#'
#' @examples
#' \dontrun{
#' # Create random matrix
#' mat_rix <- matrix(rnorm(500), nc=5)
#' # Calculate eigen decomposition
#' ei_gen <- HighFreq::calc_eigen(scale(mat_rix, scale=FALSE))
#' # Calculate PCA
#' pc_a <- prcomp(mat_rix)
#' # Compare PCA with eigen decomposition
#' all.equal(pc_a$sdev^2, drop(ei_gen$values))
#' all.equal(abs(unname(pc_a$rotation)), abs(ei_gen$vectors))
#' }
#' @export
calc_eigen <- function(mat_rix) {
    .Call('_HighFreq_calc_eigen', PACKAGE = 'HighFreq', mat_rix)
}

#' Calculate the regularized inverse of the covariance matrix of returns using 
#' \emph{RcppArmadillo}.
#' 
#' @param mat_rix A numeric \emph{matrix} of returns data.
#' @param max_eigen The number of eigenvalues and eigenvectors used for
#'   calculating the inverse.
#'
#' @return A numeric \emph{matrix} equal to the regularized inverse. 
#'
#' @details The function \code{calc_inv()} first calculates the covariance 
#'   matrix of the \code{mat_rix}, and then it calculates the regularized
#'   inverse from the truncated eigen decomposition.
#'   It uses only the largest \code{max_eigen} eigenvalues and their
#'   corresponding eigenvectors.
#'
#' @examples
#' \dontrun{
#' # Create random matrix
#' mat_rix <- matrix(rnorm(500), nc=5)
#' max_eigen <- 3
#' # Calculate regularized inverse using RcppArmadillo
#' in_verse <- HighFreq::calc_inv(mat_rix, max_eigen)
#' # Calculate regularized inverse from eigen decomposition in R
#' ei_gen <- eigen(cov(mat_rix))
#' inverse_r <-  ei_gen$vectors[, 1:max_eigen] %*% (t(ei_gen$vectors[, 1:max_eigen]) / ei_gen$values[1:max_eigen])
#' # Compare RcppArmadillo with R
#' all.equal(in_verse, inverse_r)
#' }
#' @export
calc_inv <- function(mat_rix, max_eigen) {
    .Call('_HighFreq_calc_inv', PACKAGE = 'HighFreq', mat_rix, max_eigen)
}

#' Simulate a \emph{GARCH} process using \emph{Rcpp}.
#' 
#' @param om_ega Parameter proportional to the long-term average level of variance.
#' @param al_pha The weight associated with recent realized variance updates.
#' @param be_ta The weight associated with the past variance estimates.
#' @param in_nov A numeric \emph{vector} of innovations (random numbers).
#' 
#' @return A numeric \emph{matrix} with two columns: the simulated returns and
#'   variance, and with the same number of rows as the length of the argument 
#'   \code{in_nov}.
#'
#' @details The function \code{sim_garch()} simulates a \emph{GARCH} process
#'   using \emph{Rcpp}.
#'
#' @examples
#' \dontrun{
#' # Define the GARCH model parameters
#' om_ega <- 0.01
#' al_pha <- 0.5
#' be_ta <- 0.2
#' # Simulate the GARCH process using Rcpp
#' garch_rcpp <- sim_garch(om_ega=om_ega, al_pha=al_pha, be_ta=be_ta, in_nov=rnorm(10000))
#' }
#' @export
sim_garch <- function(om_ega, al_pha, be_ta, in_nov) {
    .Call('_HighFreq_sim_garch', PACKAGE = 'HighFreq', om_ega, al_pha, be_ta, in_nov)
}

#' Simulate an \emph{Ornstein-Uhlenbeck} process using \emph{Rcpp}.
#' 
#' @param eq_price The equilibrium price. 
#' @param vol_at The volatility of returns.
#' @param the_ta The strength of mean reversion.
#' @param in_nov A numeric \emph{vector} of innovations (random numbers).
#' 
#' @return A numeric \emph{vector} representing the time series of prices, with
#'   the same length as the argument \code{in_nov}.
#'
#' @details The function \code{sim_ou()} simulates an \emph{Ornstein-Uhlenbeck}
#'   process using \emph{Rcpp}, and returns a \emph{vector} representing the 
#'   time series of prices.
#'
#' @examples
#' \dontrun{
#' # Define the Ornstein-Uhlenbeck model parameters
#' eq_price <- 5.0
#' vol_at <- 0.01
#' the_ta <- 0.01
#' # Simulate Ornstein-Uhlenbeck process using Rcpp
#' price_s <- HighFreq::sim_ou_rcpp(eq_price=eq_price, vol_at=vol_at, the_ta=the_ta, in_nov=rnorm(1000))
#' }
#' @export
sim_ou <- function(eq_price, vol_at, the_ta, in_nov) {
    .Call('_HighFreq_sim_ou', PACKAGE = 'HighFreq', eq_price, vol_at, the_ta, in_nov)
}

#' Recursively filter a vector of innovations through a vector of \emph{ARIMA} 
#' coefficients.
#' 
#' @param in_nov A numeric \emph{vector} of innovations (random numbers).
#' @param co_eff A numeric \emph{vector} of \emph{ARIMA} coefficients.
#'
#' @return A numeric \emph{vector} of the same length as the argument
#'   \code{in_nov}.
#'
#' @details The function \code{sim_arima()} recursively filters a vector of
#'   innovations through a vector of \emph{ARIMA} coefficients, using 
#'   \emph{RcppArmadillo}.
#'   It performs the same calculation as the standard \emph{R} function
#'   \code{filter(x=in_nov, filter=co_eff, method="recursive")}, but it's about
#'   six times faster.
#'   
#' @examples
#' \dontrun{
#' # create vector of innovations
#' in_nov <- rnorm(100)
#' # create ARIMA coefficients
#' co_eff <- c(-0.8, 0.2)
#' # calculate recursive filter using filter()
#' filter_ed <- filter(in_nov, filter=co_eff, method="recursive")
#' # calculate recursive filter using RcppArmadillo
#' ari_ma <- HighFreq::sim_arima(in_nov, rev(co_eff))
#' # compare the two methods
#' all.equal(as.numeric(ari_ma), as.numeric(filter_ed))
#' }
#' @export
sim_arima <- function(in_nov, co_eff) {
    .Call('_HighFreq_sim_arima', PACKAGE = 'HighFreq', in_nov, co_eff)
}

#' Calculate the maximum Sharpe ratio portfolio weights for the matrix returns,
#' using the regularized inverse of the covariance matrix, and
#' \emph{RcppArmadillo}.
#' 
#' @param re_turns A numeric \emph{matrix} of returns data.
#' 
#' @param vec_tor A numeric \emph{vector} of data.
#' @param look_back The length of the look-back interval, equal to the number of rows
#'   of data used for calculating the variance.
#'
#' @return A numeric \emph{vector} of the same length as the argument \code{vec_tor}.
#'
#' @details The function \code{calc_weights()} calculates a \emph{vector} of rolling 
#'   variance estimates, from over a \emph{vector} of returns, using \emph{Rcpp}.
#'
#' @examples
#' \dontrun{
#' # create minutely OHLC time series of random prices
#' vec_tor <- HighFreq::random_ohlc()
#' # calculate variance estimates for vec_tor over a 21 period interval
#' var_rolling <- HighFreq::calc_weights(vec_tor, look_back=21)
#' # calculate variance estimates for SPY
#' var_rolling <- HighFreq::calc_weights(HighFreq::SPY, calc_method="yang_zhang")
#' # calculate SPY variance without accounting for overnight jumps
#' var_rolling <- HighFreq::calc_weights(HighFreq::SPY, calc_method="rogers_satchell")
#' }
#' @export
calc_weights <- function(re_turns, alpha_s, alphas_b, max_eigen) {
    .Call('_HighFreq_calc_weights', PACKAGE = 'HighFreq', re_turns, alpha_s, alphas_b, max_eigen)
}

#' Simulate (backtest) a rolling portfolio optimization strategy.
#' 
#' @param re_turns A numeric \emph{matrix} of returns data.
#' 
#' @param vec_tor A numeric \emph{vector} of data.
#' @param look_back The length of the look-back interval, equal to the number of rows
#'   of data used for calculating the variance.
#'
#' @return A numeric \emph{vector} of the same length as the argument \code{vec_tor}.
#'
#' @details The function \code{roll_portf()} calculates a \emph{vector} of rolling 
#'   variance estimates, from over a \emph{vector} of returns, using \emph{Rcpp}.
#'
#' @examples
#' \dontrun{
#' # create minutely OHLC time series of random prices
#' vec_tor <- HighFreq::random_ohlc()
#' # calculate variance estimates for vec_tor over a 21 period interval
#' var_rolling <- HighFreq::roll_portf(vec_tor, look_back=21)
#' # calculate variance estimates for SPY
#' var_rolling <- HighFreq::roll_portf(HighFreq::SPY, calc_method="yang_zhang")
#' # calculate SPY variance without accounting for overnight jumps
#' var_rolling <- HighFreq::roll_portf(HighFreq::SPY, calc_method="rogers_satchell")
#' }
#' @export
roll_portf <- function(ex_cess, re_turns, start_points, end_points, al_pha, max_eigen) {
    .Call('_HighFreq_roll_portf', PACKAGE = 'HighFreq', ex_cess, re_turns, start_points, end_points, al_pha, max_eigen)
}

